# 2798 번 문제 

# 문제 요약 
'''
N장의 카드가 주어지고, M의 숫자와 가장 가깝게 3장의 카드를 합쳐서 
합을 만들어야 하는 문제. (단, 카드의 합은 M을 넘으면 안된다.)
'''

# 문제풀이 방식 
'''
입력받은 N장의 카드 숫자를 배열에 담아서 
N장 중에서 3개의 카드를 뽑는 방식이 인덱스번호를 랜덤 모듈을 써서 
3장의 카드를 뽑는다. 
3장의 카드 합이 21보다 작을 경우에만 숫자합을 비교할 수 있는 배열에 담는다. 
배열에 이미 같은 숫자가 있다면, 중복 제거 한다.
해당 배열에서 max 함수를 통해 가장 큰 합산을 찾아서 출력 
=> 하지만, 랜덤식으로 하니 가장 큰 합산이 계속 달라지는 문제로 
알아보니 그냥 반복문 돌리면 되는 문제였다. 
-> 이 방식은 알고 있었지만 까다로울 것이라고 생각해서 다른 방식을 
생각했었는데 이제부터 한번 시도해보고 생각해보자. 
'''


# 완전 탐색 풀이 
import sys 

N,M = map(int,input().split())
arr = list(map(int,sys.stdin.readline().split()))

result = 0 
for i in range(N) : 
  for j in range(i+1,N) : 
    for k in range(j+1, N) : 
      if (arr[i]+arr[j]+arr[k] <= M) : 
        result = max(result, arr[i]+arr[j]+arr[k])
        # 작은 합들 중 가장 큰 합을 result 에 저장함. 

print(result)

# max 함수
'''
인자값이 여러 개면, 인자 값 들중 가장 큰 값을 비교해서 반환한다. 
그래서 result = max(result, arr[i]+arr[j]+arr[k]) 이 방식은 
5+6+7 = 18 과 result 0 과 비교해서 18 을 result 값에 대입
5+6+8 = 19 과 result 18 과 비교해서 19 을 result 값에 대입
5+6+9 = 20 과 result 19 과 비교해서 20 을 result 값에 대입
  : 
이 되는것이다. 
'''
      


'''
567
568
569
;
578
579
;
589
;
678
679
;
689
;
789

'''
    




