# 2609 번 문제 

# 최대공약수와 최소공배수 구하는 문제 

# 문제풀이 방식
'''
입력받은 두 값의 각각 약수들을 리스트에 담고 
두 리스트의 공통된 약수 중 가장 큰 약수가 최대 공약수가 된다.
최소 공배수는 입력받은 두값을 각각 최대공약수로 나눴을 때 몫 2개를 
곱한 뒤 최대공약수를 한번더 곱하면 된다. 
'''

import sys 
import math # math 모듈 이용 할 시

sm = 0 # 최대공약수 
bg = 0 # 최소공배수 
a,b = map(int,sys.stdin.readline().split())
a_lst = [] # a 의 약수들 
b_lst = [] # b 의 약수들 
# a,b 의 약수를 구해서 거기서 공통된 약수 중 최대 공약수를 구한다. 
for i in range(1,a+1) : 
  if a % i == 0 : 
    a_lst.append(i)

for j in range(1,b+1) : 
  if b % j == 0 :
    b_lst.append(j)

# a_lst 안에 b_lst의 원소와 같은 값 최대 값 출력 
sm = max([i for i in a_lst if i in b_lst])

# 1)최대공약수로 구하는 최소공배수  
bg = (a//sm) * (b//sm) * sm
# 2) 입력받은 두 값을 곱한 뒤 최대공약수로 나누어주면 최소공배수를 구할 수 있다. 
bg = int((a * b) / sm) 

#print(sm)
#print(bg)

# 런타임 에러 일어나는 이유 
'''
1.배열에 할당된 크기를 넘어서 접근했을 때
2.전역 배열의 크기가 메모리 제한을 초과할 때
3.지역 배열의 크기가 스택 크기 제한을 넘어갈 때
4.0으로 나눌 떄  -> 나는 이 문제로 런타임에러가 났었다. 
5.라이브러리에서 예외를 발생시켰을 때
6.재귀 호출이 너무 깊어질 때
7.이미 해제된 메모리를 또 참조할 때
'''
# 4번 문제인 것 같아서 다시 보니, 2부터 자기자신까지 나눠서 약수를 구하고 있었어서 1부터 자기자신으로 바꾸어주었더니 해결되었다.

# 다른 사람 풀이를 보니 
# math 라는 파이썬 모듈이 따로 있었어서 모듈에서 지원하는 함수를 통해 
# 간단하게 풀 수도 있다. -> lcm 파이썬 3.9 버전 이상부터 지원함
print(math.gcd(a,b))
print(math.lcm(a,b))

'''
유클리드 호제법 : 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘 
a,b 에서 a 를 b 로 나눈 나머지를 r 이라하면 (단, a>b),
a 와 b 의 최대공약수는 b와 r의 최대공약수와 같다. 
이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고, 다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.
'''
#유클리드 호제법을 사용하게 될 경우 
def gcd(a,b):
  while b>0 : 
    print(b)
    a,b = b,a%b 
  return a 
print(gcd(a,b)) #최대공약수를 구할 수 있다. 