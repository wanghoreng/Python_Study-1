# Greedy : 1이 될 때 까지 (이코테 p99)
'''
1. N에서 1을 뺀다.
2. N을 K로 나눈다. (N이 K로 나누어떨어질때만 가능)

1번과 2번 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 
이 때 1이 될 때 까지 과정을 실행한 최소 횟수를 구하는 문제이다. 
'''

# 조건 
'''
2 <= N,K <= 100,000
두개의 입력값을 모두 자연수로만 주어진다.
'''

# 입력 예시 
'''
25 5 
=> 2 
'''

n,k = map(int,input().split())

# 횟수 세기
count = 0 

while n!= 1 : 
  if n%k == 0 :  # 2번과정 
    n = int(n/k)
  else :   # 1번과정 
    n -= 1 
  count += 1

print(count)

# 내가 생각한 시간복잡도 
'''
하한선이 나누어떨어지는 최소횟수가 아닌 안 나누어 떨어져서 계속 -1 한다고 가정했을 때 
n번을 -1 하는 것이기 때문에 O(N) 이라고 생각한다. 
'''

# 내 코드의 단점 
'''
N이 100억이상의 큰 수가 됐을 때 시간초과가 나는 코드이다. 
게다가 N이 K로 나누어떨어지거나,아니거나 로만 분기를 나눈채 반복을 하기 때문에 N이 K로 안나누어떨어질땐 무조건 -1 한 다음에 다음 반복을 다시 한다. 
조금 더 생각해본다면 n이 k로 안나누어떨어진다면 먼저 -1 을 하고 그 이후 반복문 돌기전에 n을 k로 나누는 연산을 한다면 반복문이 한번 더 돌아서 조건식을 비교하는 연산이 없어지게 된다. 
시간복잡도를 생각하기 이전에 먼저 이러한 불필요한 연산을 빼고 연산하는 코드를 작성하는 게 중요해보인다. 
'''

#정답 코드 1 
n,k = map(int,input().split())

# 횟수 세기
count = 0 

while n >= k : 
  while n%k != 0 :  
    n -= 1   # 1번과정 
    count += 1  
  # 2번과정 
  n = n//k
  count += 1

# K로 나누어떨어지지 않았던 나머지를 빼는 연산 
while n > 1 :
  n -= 1  
  count += 1 

print(count)

# 정답 코드 2 => 시간 복잡도를 고려한 계산 
n, k = map(int,input().split())
result = 0 

while True : 
  # (n==k로 나누어떨어지는 수)가 될 때까지 1 씩 빼기
  target = (n//k) * k # 이 식을 통해 n이 k의 배수로 만들 수 있다. 
  result += (n-target) # 빼는 이유는 k의 배수로 만들게 되면서 한번에 -1을 여러번 한 것이 되기 때문이다 
  n = target # 14 
  if n < k :  # n을 k로 더이상 나눌 수 없을 때 반복문을 탈출한다. 
    break
  result += 1 
  n //= k  # k의 배수로 만들어진 n을 k로 나누어떨어지게 만들었다. 

# 마지막으로 남은 수에 대하여 1씩 빼기 
result += (n-1) 
print(result)
