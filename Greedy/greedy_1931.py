
# 1931 번 - 회의실 배정 

# 문제 접근방식
'''
1.시작시간이 가장 작은 시간
2.시작시간과 끝나는시간이 가장 짧은 시간

먼저,시작시간에 맞춰 정렬한 후 끝나는 시간에 맞춰 정렬해야한다. 
끝나는 시간으로 결국 정렬하는 이유는 시작시간이 0 , 끝나는 시간이 12 면 
시작시간으로 정렬했을 때 0 이어서 다음 정렬을 확인해야하지만, 결국 끝나는 시간은 12여서 다음 회의를 더 잡을 수 없기 때문이다. 
하지만 끝나는 시간 순으로 정렬을 한다면, 아래처럼 입력받았을 때 
0 10 
1 2
2 3 
=> [1,2] [2,3] [0,10]
처럼 고려할 수 있는 것이 더 많기 때문이다. 

그러나, 시작시간을 먼저 정렬한뒤 끝나는 시간을 정렬해야 하는 이유는 
시작시간과 끝나는 시간이 같은 경우도 있기 때문이다.

예를 들어, 
2 2 
1 2 
=> [2,2][1,2] 로 정렬이 된다면 원하는 바와 같이 나오지 않기 때문이다. 
그래서 먼저 시작시간으로 정렬해서 [1,2][2,2] 형태로 한 후 끝나는 시간으로 정렬해줘야 회의시간 가능한 횟수가 똑바로 출력이 나오게 된다. 
'''

import sys
n = int(sys.stdin.readline().rstrip())

# 시작시간, 끝나는 시간을 공백으로 구분하여 2차원 배열 저장
meeting = [list(map(int,sys.stdin.readline().rstrip().split())) for _ in range(n)]


# 시작시간이 작은 순으로 정렬 
meeting = sorted(meeting, key= lambda x : x[0])
# 끝나는 시간의 작은 순으로 정렬 
meeting = sorted(meeting, key= lambda x : x[1])

# 횟수 세기
count = 1
# 처음 회의가 끝나는 시간 저장
end_time = meeting[0][1] 

for i in range(1,n) : 
  if meeting[i][0] >= end_time :  #끝나는 시간과 같은 시작시간이 있을 경우
    count += 1 
    end_time = meeting[i][1]   #해당 회의가 끝나는 시간을 저장한다. 

print(count)



