# 1026 - 보물 문제 

'''
S = A[0]*B[0]+A[1]*B[1]+A[2]*B[2]+..+A[n-1]*B[n-1]


S의 최소값을 만들기 위해서는 곱해지는 값들이 모두 최소가 되어야한다.
그럼 곱해지는 값들인 A[]*B[]의 수들이 가장 작은 최소가 되기 위해서는 
A의 가장 작은값과 B의 가장 큰 값이 곱해지는 것이 최소 일 것이다. 
또는 A의 가장 큰 값과 B의 가장 작은 값이 곱해지는 것이 최소이다.

그러나, 가장 중요한 겂은 A만 재배열이 가능하다는 것. 
그럼 B의 수에 맞게 A가 재배열이 되어야한다. 

b의 가장 큰 순서대로 인덱스를 찾는다.
b 의 가장 큰 수

1 1 1 6 0 
2 7 8 3 1 

1 1 0 1 6 
2 7 8 3 1 
'''

# n = int(input())
# a = list(map(int,input().split()))
# b = list(map(int,input().split()))

# # a를 가장 작은수로 정렬
# a.sort()

# # b를 가장 큰 수 내림차순 정렬
# b_compare = sorted(b,reverse=True)

# # 재배열한 a 를 넣을 리스트를 n크기로 선언 및 리스트 크기 초기화
# x = [0 for i in range(n)] 

# for i in range(n) : 
#   k = b.index(b_compare[i]) # b의 숫자가 가장 큰 순서대로 인덱스를 찾아서 반환 
#   x[k] = a[i] # 해당 인덱스에 a의 값을 넣음 

# s = 0 
# for i in range(n) : 
#   s += x[i]*b[i] # 문제의 s 구하는 방식

# print(s)

# 방식이 틀림 
'''
위의 문제풀이방식으로 문제를 푸니, 
테스트 케이스는 다 맞았으나, b의 원소로 모두 같은 숫자가 들어가게 될 경우
index 함수를 통해 같은 숫자만 찾게 되므로 
a의 재배열이 제대로 안되어서 정답으로 인정이 되지 않았다. 
'''

n = int(input())
a = list(map(int,input().split()))
b = list(map(int,input().split()))

s = 0 
for i in range(n) : 
  s += min(a) * max(b)    # 가장 작은 값을 찾고, 가장 큰 값을 찾아 곱해준다. 
  a.pop(a.index(min(a)))  # 같은 인덱스를 참조하지 못하도록 pop 각 인덱스를 찾아 pop 해준다. 
  b.pop(b.index(max(b))) 
print(s)

'''
참 간단하게도, 그냥 min,max 를 찾아 곱해주고 해당 리스트에서 제거해주면 되는 것인데, 이 문법을 다 알고 있었음에도 불구하고
더 어렵게 구하고 있었다.. 
조금 더 쉽게 생각을 해보도록 하고 최대한 머리로만 생각하지말고 
직접 써보면서 빠르게 풀려고 노력하자 
'''