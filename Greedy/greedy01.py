# Greedy 

# 큰 수의 법칙 (이코테 p92)
'''
다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 특징이다. 

예를 들어, 2,4,5,4,6 일 경우, M이 4, K가 2라면 
6+6+5+6 으로 계산이 되어야한다. 
배열에 같은 숫자가 존재하더라도, 서로 다른 것으로 간주한다. 
'''

# 조건 
'''
배열의 크기 N, 숫자가 더해지는 횟수 M, K 주어질 때 결과 출력하기.
'''

# 입력예시 및 답
'''
5 8 3 
2 4 5 4 6
=> 46 
'''

# 풀이 
import sys
N,M,K = map(int,sys.stdin.readline().rstrip().split()) 
N = list(map(int,input().split()))

# 누적 합
sum = 0 
# 가장 큰 순서대로 정렬하기 
N =sorted(N,reverse=True) 

# M번 더하기
for i in range(1,M+1) : 
  if(i % (K+1) == 0) : # 연속해서 가장 큰 숫자를 더한 횟수가 K개를 넘었을 때, K+1번째를 두번째로 큰 숫자 더하는 방식.
    sum += N[1] 
  else : 
    sum += N[0] # 그게 아닐 경우 가장 큰 숫자 더하기 

print(sum)
  

'''
내가 생각하는 시간 복잡도
O(M)
'''

# 정답 코드 
n,m,k = map(int,input().split())
data = list(map(int,input().split()))

data.sort() # 입력받은 수 오름차순 정렬 
first = data[n-1] # 가장 큰 숫자 저장 
second = data[n-2] # 두번째로 큰 숫자 저장

# 가장 큰 숫자가 더해지는 횟수
count = int(m / (k+1)) * k 
count += m % (k+1) # M이 (K+1) 로 나누어떨어지지 않을 때도 고려하여 나눈 나머지를 더한다. 

result = 0
result += (count) * first # 가장 큰 숫자가 더해지는 횟수에 가장 큰 숫자를 곱한것  
result += (m-count) * second # 총 더해지는 횟수에서 가장 큰 숫자가 더해지는 횟수를 뺀 숫자만 두번째로 큰 숫자에 곱한 것 

print(result)

'''
이 방식은 M이 10,000 이하일 때가 아닌, M의 크기가 100억 이상처럼 커질 때도 고려하여 
짠 코드이다. 시간 복잡도를 고려하는 방식을 조금 더 생각해 보아야할 것 같다. 
'''